## usethis namespace: start
#' @useDynLib BFAST, .registration = TRUE
#' @importFrom Rcpp sourceCpp
## usethis namespace: end
NULL


approxPCA <- function(Y, q){ ## speed the computation for initial values.
  # require(irlba)
  n <- nrow(Y)
  svdY  <- irlba(A =Y, nv = q)
  PCs <- svdY$u %*% diag(svdY$d[1:q])
  loadings <- svdY$v
  dY <- PCs %*% t(loadings) - Y
  W <- colSums(dY^2)/n
  return(list(PCs = PCs, loadings = loadings, W=W))
}

#' @export
InitalPara<-function(Y,K,q,approxPCA=FALSE,int.model="EEE",wpca.int=TRUE){

  Y=scale(Y,scale=F)
  if(approxPCA){
    message("Using approxmated PCA to obtain initial values")
    princ <- approxPCA(Y, q)
  }else{
    message("Using accurate PCA to obtain initial values")
    princ <- BFAST::wpcaCpp(Y, q, weighted=wpca.int)
  }

  # W_int=princ$W
  # A_int=princ$loadings
  # Z=princ$PCs

  pa=fa(Y,q,fm="pa",residuals = T,rotate="varimax")
  A_int=pa$loadings
  Z=pa$scores
  W_int=diag(pa$residual)

  mclus2 <- Mclust(Z, K, int.model)

  x_int <- mclus2$classification
  alpha0=rep(0,K)

  mu_int=unname(mclus2$parameters$mean)
  sigma_int=unname(mclus2$parameters$variance$sigma)

  Pi=mclus2$parameters$pro

  Y_mean=matrix(colMeans(Y),ncol=1)

  for(k in 1:K){
    Y_mean=Y_mean-Pi[k]*A_int%*%mu_int[,k]
  }
  mu0_int=Y_mean

return(list=list(x_int=x_int,A_int=A_int,W_int=W_int,mu0_int=mu0_int,mu_int=mu_int,sigma_int=sigma_int))
}


#' ICMEM.
#'
#' @description
#' The function ICMEM was used to conduct spatial clustering with hidden Markov random field for a sequence of beta and fixed number of clusters
#'
#' @details The function ICMEM was used to conduct spatial clustering with hidden Markov random field for fixed beta and fixed number of clusters
#' @param y is a matrix of PCs containing gene expression.
#' @param x_int is a vector of initial cluster label.
#' @param Adj is a matrix containing neighborhood information generated by find_neighbors2.
#' @param mu_int is a initial mean vector. we often generated it by Gaussian mixture model.
#' @param sigma_int is a initial co-variance matrix. we often generated it by Gaussian mixture model.
#' @param alpha is a intercept.
#' @param beta_grid is a sequence of smoothing parameter that can be specified by user.
#' @param PX is a logical value specifying the parameter expansion in EM algorithm.
#' @param maxIter_ICM is the maximum iteration of ICM algorithm.
#' @param maxIter is the maximum iteration of EM algorithm.
#' @return a list.
#'
#' The item 'x' is the clustering result.
#'
#' The item 'gam' is the posterior probability matrix.
#'
#' The item 'ell' is the opposite log-likelihood.
#'
#' The item 'mu' is the mean of each component.
#'
#' The item 'sigma' is the variance of each component.
#'
#' @export
ICMEM <- function(Y, x_int, Adj, A_int, mu0_int, W_int, mu_int, sigma_int, lambda_grid, alpha, beta_grid, maxIter_ICM, maxIter) {
  .Call(`_BFAST_ICMEM`, Y, x_int, Adj, A_int, mu0_int, W_int, mu_int, sigma_int, lambda_grid, alpha, beta_grid, maxIter_ICM, maxIter)
}

#' @export
# get the optimal number of latent embeddings
selectFacNumber <- function(X, qmax=15){
  mnlamjFun <- function(eigvals, j){
    p <- length(eigvals)
    lamj <- eigvals[j]
    Sum <- 0
    for(l in (j+1):p){
      Sum <- Sum + 1/(eigvals[l] - lamj)
    }
    res <- Sum + 1/ ((3*lamj + eigvals[j+1])/4 - lamj)
    return(res/(p-j))
  }
  mtnlamjFun <- function(n, eigvals, j){
    p <- length(eigvals)
    rhojn <-  (p-j)/(n-1)
    res <- -(1-rhojn)/ eigvals[j] + rhojn * mnlamjFun(eigvals, j)
    return(res)
  }
  n <- nrow(X)
  p <- ncol(X)
  corMat <- cor(X)
  evalues <- eigen(corMat)$values
  hq1 <- sum(evalues>1+sqrt(p/(n-1)))
  if(hq1 < 15){
    hq <- hq1
  }else{ # ajdust the eigvalues
    adj.eigvals <- sapply(1:(p-1), function(j) -1/mtnlamjFun(n, evalues, j))
    hq <- sum(adj.eigvals >1) # overselect
  }
  if(hq > qmax || hq < 5) hq <- qmax

  propvar <- sum(evalues[1:hq]) / sum(evalues)
  res <- list()
  res$q <- hq
  res$propvar <- sum(evalues[1:hq]) / sum(evalues)

  return(res)
}
                        
#' @export
gendata <- function(height=60, width=60, platform="ST", p =100, D=15, K=5, method="exp",
                    G=4, decay_coef=0.2, range_from_value=0.2, sigma2=1, seed=1, view=FALSE){

  if(D <2) stop("error:gendata_sp::D must be greater than 2!")

  #require(MASS)
  n <- height * width # # of cell in each indviduals

  if(platform=="ST"){
    beta = 1
  }else if(platform=='scRNAseq'){
    beta = 0
  }
  ## generate deterministic parameters, fixed after generation

  A <- matrix(rnorm(p*D), p, D)
  A <- qr.Q(qr(A))
  mu <- matrix(0, D, K)
  diagmat = array(0, dim = c(D, D, K))

  for(k in 1:K){
    mu[,k]=rnorm(D)
    diag(diagmat[,,k])=abs(rnorm(D))
  }

  Mu <- t(mu)
  Sigma <- diagmat
  #set.seed(seed)
  # generate the spatial dependence for state variable x, a hidden Markov RF
  x <- GiRaF::sampler.mrf(iter = n, sampler = "Gibbs", h = height, w = width, ncolors = K, nei = G, param = beta,
                          initialise =FALSE,view = view)
  x <- c(x) + 1

  Z <- matrix(0, n, D)

  for(k in 1:K){
    nk <- sum(x==k)
    Z[x==k, ] <- MASS::mvrnorm(nk, Mu[k,], Sigma[,,k])
  }

  mu = rep(0,p)
  mu = 2*range_from_value*runif(p)+(1-range_from_value)
  W <- sigma2*abs(rnorm(p, sd=1))
  noise = matrix(0,n,p)

  for(j in 1:p)
    noise[,j] = mu[j] + rnorm(n,0,W[j])

  Y = Z%*%t(A) + noise
  Y[Y < 0] = 0

  rand_matrix = matrix(runif(n*p),n,p)
  if(method=="exp"){
    cutoff = exp(-decay_coef*(Y^2))
  }
  if(method=="linear"){
    cutoff = 1-decay_coef*Y
    cutoff[cutoff<0]=0
    cutoff[cutoff>1]=1
  }
  zero_mask = rand_matrix < cutoff
  Y[zero_mask] = 0

  # make position
  pos <- cbind(rep(1:height, width), rep(1:height, each=width))

  counts <- t(Y)
  p <- ncol(Y)
  n <- nrow(Y)
  rownames(counts) <- paste0("gene", seq_len(p))
  colnames(counts) <- paste0("spot", seq_len(n))
  counts=as.matrix(exp(counts)-1)

  ## Make array coordinates - filled rectangle
  if(platform=="ST"){
    cdata <- list()
    cdata$row <- pos[,1]
    cdata$col <- pos[,2]
    cdata <- as.data.frame(do.call(cbind, cdata))
    cdata$imagerow <- cdata$row
    cdata$imagecol <- cdata$col
    row.names(cdata) <- colnames(counts)

    #library(Seurat)
    ## Make SCE
    seu <-  Seurat::CreateSeuratObject(counts= counts, meta.data=cdata) #
  }else if(platform=='scRNAseq'){
    # library(Seurat)
    ## Make SCE
    seu <-  Seurat::CreateSeuratObject(counts= counts)
  }else{
    stop("gendata_RNAExp: Unsupported platform \"", platform, "\".")
  }
    
  seu$true_clusters <- x
  return(list(data=seu,Y=Y,Z=Z,A=A,Mu=Mu,Sigma=Sigma,mu=mu,W=W,x=x))
}

# #testdata
# library(Seurat)
# library(GiRaF)
# library(mclust)
# library(psych)
# library(SingleCellExperiment)

# a=gendata(decay_coef=0.2)
# data=a$data
# data.sce=Seurat::as.SingleCellExperiment(Seurat::DietSeurat(data))
# spot_x=data@meta.data$row
# spot_y=data@meta.data$col
# data.sce@colData@listData$row=spot_x
# data.sce@colData@listData$col=spot_y
# Adj=SC.MEB::find_neighbors2(data.sce,platform="ST")
#
# D=15
# K=5
# y=scale(a$Y,center=F)
# out=InitalPara(y,K,D)
# res=BFAST::ICMEM(y,out$x_int,Adj,out$A_int,out$mu0_int,diag(as.vector(out$W_int)),out$mu_int,out$sigma_int,lambda_grid=seq(0.5,1,0.1),alpha=rep(0,K),beta_grid=seq(0,1,0.1), maxIter_ICM=10, maxIter=50)

